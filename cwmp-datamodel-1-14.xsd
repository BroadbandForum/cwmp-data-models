<?xml version="1.0" encoding="UTF-8"?>
<!--
  Data Model Definition Schema (DM Schema) v1.14

  Copyright (c) 2008-2024, Broadband Forum

  Redistribution and use in source and binary forms, with or
  without modification, are permitted provided that the following
  conditions are met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above
     copyright notice, this list of conditions and the following
     disclaimer in the documentation and/or other materials
     provided with the distribution.

  3. Neither the name of the copyright holder nor the names of its
     contributors may be used to endorse or promote products
     derived from this software without specific prior written
     permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  The above license is used as a license under copyright only.
  Please reference the Forum IPR Policy for patent licensing terms
  <https://www.broadband-forum.org/ipr-policy>.

  Any moral rights which are necessary to exercise under the above
  license grant are also deemed granted under this license.

  Summary:
    CWMP and USP Data Model Definition Schema (DM Schema). DM Instances define CWMP
    or USP data models.  Within the schema, elements are grouped by category (simple
    types, complex types etc), and are in alphabetical order within each category.

  Comments or questions about this Broadband Forum data model should be
  directed to <info@broadband-forum.org>.
-->

<!DOCTYPE cwmp-datamodel [
  <!ENTITY colon ":">
  <!ENTITY hash "#">
  <!ENTITY dot "\.">
  <!ENTITY inst "(\{i\})">
  <!ENTITY name "([\i-[:]][\c-[:\.]]*)">
  <!ENTITY Name "([\i-[a-z:]][\c-[:\.]]*)">
  <!ENTITY num "(\d+)">
  <!ENTITY exclam "!">
  <!ENTITY parens "\(\)">
]>

<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning" vc:minVersion="1.1"
  xmlns:tns="urn:broadband-forum-org:cwmp:datamodel-1-14"
  xmlns:dmr="urn:broadband-forum-org:cwmp:datamodel-report-1-0"
  targetNamespace="urn:broadband-forum-org:cwmp:datamodel-1-14" elementFormDefault="unqualified"
  attributeFormDefault="unqualified">
  <xs:import namespace="urn:broadband-forum-org:cwmp:datamodel-report-1-0"
    schemaLocation="https://www.broadband-forum.org/cwmp/cwmp-datamodel-report-1-0.xsd"/>
  <!-- Open content (replaces need for individual xs:any elements) -->
  <!-- XXX still need xs:anyAttribute but can handle this via the type hierarchy -->
  <xs:defaultOpenContent>
    <xs:any namespace="##other"/>
  </xs:defaultOpenContent>
  <!-- Simple types -->
  <xs:simpleType name="AbbrefId">
    <xs:annotation>
      <xs:documentation>Abbreviation item ID; SHOULD uniquely identify this item across all instance documents.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String"/>
  </xs:simpleType>
  <xs:simpleType name="ActiveNotify">
    <xs:annotation>
      <xs:documentation>Parameter active notify support.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:enumeration value="normal"/>
      <xs:enumeration value="forceEnabled"/>
      <xs:enumeration value="forceDefaultEnabled"/>
      <xs:enumeration value="canDeny"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="AnyTypeName">
    <xs:annotation>
      <xs:documentation>Built-in or derived type name.</xs:documentation>
    </xs:annotation>
    <xs:union memberTypes="tns:BuiltinTypeName tns:DataTypeName"/>
  </xs:simpleType>
  <xs:simpleType name="ArgumentDefaultType">
    <xs:annotation>
      <xs:documentation>Type of argument parameter default.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:enumeration value="parameter">
        <xs:annotation>
          <xs:documentation>Default if argument parameter isn't supported.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="BibrefId">
    <xs:annotation>
      <xs:documentation>Bibliographic reference ID; SHOULD uniquely identify this reference across all instance documents.
For BBF DM Instances, the bibliographic reference ID rules specified in A.2.4 MUST be used.  For example, to reference TR-106 Issue 1 Amendment 2, the value of this attribute would be TR-106a2.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String"/>
  </xs:simpleType>
  <xs:simpleType name="BuiltinTypeName">
    <xs:annotation>
      <xs:documentation>Built-in type name.
The type hierarchy is as for XML Schema, with "any" and "base64" mapping to the "anySimpleType" and "base64Binary" XML Schema types respectively.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:enumeration value="any"/>
      <xs:enumeration value="base64"/>
      <xs:enumeration value="boolean"/>
      <xs:enumeration value="dateTime"/>
      <xs:enumeration value="decimal"/>
      <xs:enumeration value="hexBinary"/>
      <xs:enumeration value="integer"/>
      <xs:enumeration value="int"/>
      <xs:enumeration value="long"/>
      <xs:enumeration value="string"/>
      <xs:enumeration value="unsignedInt"/>
      <xs:enumeration value="unsignedLong"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="CommandName">
    <xs:annotation>
      <xs:documentation>Command name (maximum length 256); the same as xs:NCName except that dots are not permitted and it's terminated with a "()".  This name MUST in addition follow the vendor-specific parameter name requirements of section 3.3.
        A command name SHOULD NOT start with an underscore or include any hyphens.
        In BBF standards, a command name MUST NOT start with an underscore or include any hyphens.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:maxLength value="256"/>
      <xs:pattern value="&name;&parens;"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ComponentName">
    <xs:annotation>
      <xs:documentation>Component name; the same as xs:NCName except that dots are not permitted.
A component which has a name beginning with an underscore is internal and cannot be imported by another DM Instance.
In BBF standards, a component name MUST NOT include any hyphens.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:pattern value="&name;"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DataTypeName">
    <xs:annotation>
      <xs:documentation>Data type name; the same as xs:NCName except that cannot start with lower-case letter (to avoid conflict with built-in data type names) and dots are not permitted.
A data type which has a name beginning with an underscore is internal and cannot be imported by another DM Instance.
In BBF standards, a data type name MUST NOT include any hyphens.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:pattern value="&Name;"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DescriptionAction">
    <xs:annotation>
      <xs:documentation>Description action.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:enumeration value="create"/>
      <xs:enumeration value="prefix"/>
      <xs:enumeration value="append"/>
      <xs:enumeration value="replace"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="EventName">
    <xs:annotation>
      <xs:documentation>Event name (maximum length 256); the same as xs:NCName except that dots are not permitted and it's terminated with a "!".  This name MUST in addition follow the vendor-specific parameter name requirements of section 3.3.
        An event name SHOULD NOT start with an underscore or include any hyphens.
        In BBF standards, an event name MUST NOT start with an underscore or include any hyphens.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:maxLength value="256"/>
      <xs:pattern value="&name;&exclam;"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="GlorefId">
    <xs:annotation>
      <xs:documentation>Glossary item ID; SHOULD uniquely identify this item across all instance documents.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String"/>
  </xs:simpleType>
  <xs:simpleType name="ListNesting">
    <xs:annotation>
      <xs:documentation>Nested list escaping requirements.  See section 3.2.3.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:enumeration value="legacy">
        <xs:annotation>
          <xs:documentation>MUST escape inner comma separators.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="permitted">
        <xs:annotation>
          <xs:documentation>MAY escape inner comma separators; MAY use bracketed nested list syntax.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="required">
        <xs:annotation>
          <xs:documentation>MUST use bracketed nested list syntax.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="MaxEntries">
    <xs:annotation>
      <xs:documentation>Positive integer or "unbounded".</xs:documentation>
    </xs:annotation>
    <xs:union memberTypes="xs:positiveInteger">
      <xs:simpleType>
        <xs:restriction base="tns:String">
          <xs:enumeration value="unbounded"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>
  <xs:simpleType name="ModelName">
    <xs:annotation>
      <xs:documentation>Model name, including major and minor versions.  The name part is the same as xs:NCName except that dots are not permitted.
A model which has a name beginning with an underscore is internal and cannot be imported by another DM Instance.
In BBF standards, a model name MUST NOT include any hyphens.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:pattern value="&name;&colon;&num;&dot;&num;"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ModelNames">
    <xs:annotation>
      <xs:documentation>List of model names.</xs:documentation>
    </xs:annotation>
    <xs:list itemType="tns:ModelName"/>
  </xs:simpleType>
  <xs:simpleType name="MountType">
    <xs:annotation>
      <xs:documentation>Indicates whether an object is mountable or a mount point.  Mountable objects MUST be top-level children of the Root or Service Object (other objects are not permitted to be mounted).</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:enumeration value="none">
        <xs:annotation>
          <xs:documentation>This is DEPRECATED because because Mountable Objects are now determined automatically.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="mountable">
        <xs:annotation>
          <xs:documentation>This is DEPRECATED because because Mountable Objects are now determined automatically.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="mountPoint"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ObjectName">
    <xs:annotation>
      <xs:documentation>Object name (maximum length 256).  Each component is the same as xs:NCName except that dots are not permitted.  This name MUST in addition follow the vendor-specific object name requirements of section 3.3.
An object name component SHOULD NOT start with an underscore or include any hyphens.
In BBF standards, an object name component MUST NOT start with an underscore or include any hyphens.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:maxLength value="256"/>
      <xs:pattern value="(&name;&dot;(&inst;&dot;)?)+"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ObjectReference">
    <xs:annotation>
      <xs:documentation>Object path that cannot contain "{i}" placeholders and that therefore references a single object.  The path MUST follow the requirements of A.2.3.4 (its scope will typically be specified via an attribute of type PathScope).</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:pattern value="&hash;*&dot;?(&name;&dot;)*"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ObjectReferencePattern">
    <xs:annotation>
      <xs:documentation>Object path that can contain "{i}" placeholders and that can therefore references multiple objects.  The path MUST follow the requirements of A.2.3.4 (its scope will typically be specified via an attribute of type PathScope).</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:pattern value="&hash;*&dot;?(&name;&dot;(&inst;&dot;)?)*"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ObjectReferencePatterns">
    <xs:annotation>
      <xs:documentation>List of object paths, each of which can contain "{i}" placeholders.</xs:documentation>
    </xs:annotation>
    <xs:list itemType="tns:ObjectReferencePattern"/>
  </xs:simpleType>
  <xs:simpleType name="OpaqueID">
    <xs:annotation>
      <xs:documentation>Opaque ID.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:maxLength value="256"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ModelDefaultType">
    <xs:annotation>
      <xs:documentation>Type of model parameter default.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:enumeration value="factory">
        <xs:annotation>
          <xs:documentation>Default from standard, e.g. RFC.  Also applies on object creation.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="object">
        <xs:annotation>
          <xs:documentation>Default on object creation.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="implementation">
        <xs:annotation>
          <xs:documentation>Informational default that is likely after a reset or if no other value is available.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ParameterName">
    <xs:annotation>
      <xs:documentation>Parameter name (maximum length 256); the same as xs:NCName except that dots are not permitted.  This name MUST in addition follow the vendor-specific parameter name requirements of section 3.3.
A parameter name SHOULD NOT start with an underscore or include any hyphens.
In BBF standards, a parameter name  MUST NOT start with an underscore or include any hyphens.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:maxLength value="256"/>
      <xs:pattern value="&name;"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ParameterReference">
    <xs:annotation>
      <xs:documentation>Parameter path that cannot contain "{i}" placeholders and that therefore references a single parameter.  The path MUST follow the requirements of A.2.3.4 (its scope will typically be specified via an attribute of type PathScope).</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:pattern value="&hash;*&dot;?(&name;&dot;)*&name;"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="PathScope">
    <xs:annotation>
      <xs:documentation>Object / parameter path name scope (A.2.3.4).</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:enumeration value="normal"/>
      <xs:enumeration value="model"/>
      <xs:enumeration value="object"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ProfileName">
    <xs:annotation>
      <xs:documentation>Profile name, including version.  The name part is the same as xs:NCName except that dots are not permitted.
A profile name SHOULD NOT start with an underscore or include any hyphens.
In BBF standards, a profile name MUST NOT start with an underscore or include any hyphens.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:pattern value="&name;&colon;&num;"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ProfileNames">
    <xs:annotation>
      <xs:documentation>List of profile names.</xs:documentation>
    </xs:annotation>
    <xs:list itemType="tns:ProfileName"/>
  </xs:simpleType>
  <xs:simpleType name="ProfileObjectAccess">
    <xs:annotation>
      <xs:documentation>Object access (within profile).</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:enumeration value="notSpecified"/>
      <xs:enumeration value="present"/>
      <xs:enumeration value="create"/>
      <xs:enumeration value="delete"/>
      <xs:enumeration value="createDelete"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ReadWriteAccess">
    <xs:annotation>
      <xs:documentation>Read-write access.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:enumeration value="readOnly"/>
      <xs:enumeration value="readWrite"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="ParameterAccess">
    <xs:annotation>
      <xs:documentation>Parameter access options.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:enumeration value="readOnly"/>
      <xs:enumeration value="readWrite"/>
      <xs:enumeration value="writeOnceReadOnly"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="ReferenceType">
    <xs:annotation>
      <xs:documentation>Reference type (A.2.3.6).</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:enumeration value="weak"/>
      <xs:enumeration value="strong"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="Status">
    <xs:annotation>
      <xs:documentation>Item status (applies to most types of item).</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:enumeration value="current"/>
      <xs:enumeration value="deprecated"/>
      <xs:enumeration value="obsoleted"/>
      <xs:enumeration value="deleted"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="String">
    <xs:annotation>
      <xs:documentation>Base string (can't have leading or trailing whitespace).</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <!-- empty string is ignored by some tools, so use () -->
      <xs:pattern value="()"/>
      <xs:pattern value="\S"/>
      <xs:pattern value="\S.*\S"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TargetType">
    <xs:annotation>
      <xs:documentation>(Reference) target type (used in path references).</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:enumeration value="any"/>
      <xs:enumeration value="parameter"/>
      <xs:enumeration value="object"/>
      <xs:enumeration value="single"/>
      <xs:enumeration value="table"/>
      <xs:enumeration value="row"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="UniqueKeyReference">
    <xs:annotation>
      <xs:documentation>Relative parameter path name that cannot contain "{i}" placeholders and that therefore represents a valid uniqueKey parameter name.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:pattern value="(&name;&dot;)*&name;"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="UnitsString">
    <xs:annotation>
      <xs:documentation>Units string.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:maxLength value="32"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="UUID">
    <xs:annotation>
      <xs:documentation>Universally Unique IDentifier (see RFC 4122).</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:pattern
        value="[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="Version">
    <xs:annotation>
      <xs:documentation>Version (major.minor) or (major.minor.patch) in which this item was first defined.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="tns:String">
      <xs:pattern value="&num;&dot;&num;"/>
      <xs:pattern value="&num;&dot;&num;&dot;&num;"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- Attribute groups -->
  <xs:attributeGroup name="CommandAndEventParameterAttributesDef">
    <xs:attribute name="mandatory" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>If true, the parameter MUST be present.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CommandAndEventParameterAttributesRef">
    <xs:attribute name="mandatory" type="xs:boolean"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="ModelObjectAttributesDef">
    <xs:attribute name="version" type="tns:Version" use="required"/>
    <xs:attribute name="access" type="tns:ReadWriteAccess" default="readOnly"/>
    <xs:attribute name="mountType" type="tns:MountType"/>
    <xs:attribute name="enableParameter" type="tns:ParameterName">
      <xs:annotation>
        <xs:documentation>MUST be specified for a table in which the Controller can create entries and which has one or more uniqueKey elements that define functional keys.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numEntriesParameter" type="tns:ParameterName">
      <xs:annotation>
        <xs:documentation>MUST be specified for a table with a variable number of entries, i.e. for which maxEntries is greater than minEntries ("unbounded" is regarded as being greater than all values).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="dmr:fixedObject"/>
    <xs:attribute ref="dmr:noUniqueKeys"/>
    <xs:attribute ref="dmr:previousObject"/>
    <xs:attribute ref="dmr:noDiscriminatorParameter"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="ModelObjectAttributesRef">
    <xs:attribute name="access" type="tns:ReadWriteAccess"/>
    <xs:attribute name="mountType" type="tns:MountType"/>
    <xs:attribute name="enableParameter" type="tns:ParameterName"/>
    <xs:attribute name="numEntriesParameter" type="tns:ParameterName"/>
  </xs:attributeGroup>

  <!-- Model groups -->
  <xs:group name="AllBuiltinDataTypes">
    <xs:annotation>
      <xs:documentation>All built-in data types.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="base64">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="size" type="tns:SizeFacet">
                <xs:annotation>
                  <xs:documentation>Length is that of the actual string, not the base64-encoded string.  See A.2.3.3.</xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:choice>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="boolean">
        <xs:complexType>
          <xs:sequence>
          </xs:sequence>
          <xs:anyAttribute namespace="##other"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="dateTime">
        <xs:complexType>
          <xs:sequence>
          </xs:sequence>
          <xs:anyAttribute namespace="##other"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="hexBinary">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="size" type="tns:SizeFacet">
                <xs:annotation>
                  <xs:documentation>Length is that of the actual string, not the hexBinary-encoded string.  See A.2.3.3.</xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:choice>
          </xs:sequence>
          <xs:anyAttribute namespace="##other"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="decimal">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="range" type="tns:DecimalRangeFacet"/>
              <xs:element name="units" type="tns:UnitsFacet"/>
            </xs:choice>
          </xs:sequence>
          <xs:anyAttribute namespace="##other"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="int">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="instanceRef" type="tns:InstanceRefFacet"/>
              <xs:element name="range" type="tns:RangeFacet"/>
              <xs:element name="units" type="tns:UnitsFacet"/>
            </xs:choice>
          </xs:sequence>
          <xs:anyAttribute namespace="##other"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="long">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="range" type="tns:RangeFacet"/>
              <xs:element name="units" type="tns:UnitsFacet"/>
            </xs:choice>
          </xs:sequence>
          <xs:anyAttribute namespace="##other"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="string">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="size" type="tns:SizeFacet"/>
              <xs:element name="pathRef" type="tns:PathRefFacet"/>
              <xs:element name="enumeration" type="tns:EnumerationFacet"/>
              <xs:element name="enumerationRef" type="tns:EnumerationRefFacet"/>
              <xs:element name="pattern" type="tns:PatternFacet"/>
            </xs:choice>
          </xs:sequence>
          <xs:anyAttribute namespace="##other"/>
        </xs:complexType>
        <xs:unique name="stringEnumerationValue">
          <xs:selector xpath="enumeration"/>
          <xs:field xpath="@value"/>
        </xs:unique>
        <xs:unique name="stringPatternValue">
          <xs:selector xpath="pattern"/>
          <xs:field xpath="@value"/>
        </xs:unique>
      </xs:element>
      <xs:element name="unsignedInt">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="instanceRef" type="tns:InstanceRefFacet"/>
              <xs:element name="range" type="tns:RangeFacet"/>
              <xs:element name="units" type="tns:UnitsFacet"/>
            </xs:choice>
          </xs:sequence>
          <xs:anyAttribute namespace="##other"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="unsignedLong">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="range" type="tns:RangeFacet"/>
              <xs:element name="units" type="tns:UnitsFacet"/>
            </xs:choice>
          </xs:sequence>
          <xs:anyAttribute namespace="##other"/>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="AllFacets">
    <xs:annotation>
      <xs:documentation>All facets.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="size" type="tns:SizeFacet">
        <xs:annotation>
          <xs:documentation>Size facets, taken together, define the valid size ranges, e.g. (0:0) and (6:6) mean that the size has to be 0 or 6.
The size facet MUST NOT be specified for non-string data types, i.e. data types that are not derived from base64, hexBinary or string.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="instanceRef" type="tns:InstanceRefFacet">
        <xs:annotation>
          <xs:documentation>InstanceRef facets specify how a parameter can reference an object instance (table row) via its instance number.
The instanceRef facet MUST NOT be specified for data types that are not derived from int or unsignedInt.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="pathRef" type="tns:PathRefFacet">
        <xs:annotation>
          <xs:documentation>PathRef facets specify how a parameter can reference a parameter or object via its path name.
The pathRef facet MUST NOT be specified for data types that are not derived from string.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="decimalRange" type="tns:DecimalRangeFacet">
        <xs:annotation>
          <xs:documentation>Decimal range facets, taken together, define the valid value ranges, e.g. [-1:-1] and [2.6:63.7] mean that the value has to be -1 or between 2.6:63.7 inclusive (it cannot be 0).
The decimal range facet MUST NOT be specified for non-decimal data types, i.e. data types that are not derived from decimal types.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="range" type="tns:RangeFacet">
        <xs:annotation>
          <xs:documentation>Range facets taken together, define the valid value ranges with an optional step value, e.g. [-1:-1] and [1:4094] mean that the value has to be -1 or 1:4094 (it cannot be 0), [2:1024 step 2] mean all even values between 2 and 1024 inclusive.
The range facet MUST NOT be specified for non-numeric data types, i.e. data types that are not derived from one of the integer types.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="enumeration" type="tns:EnumerationFacet">
        <xs:annotation>
          <xs:documentation>Enumeration facets, taken together, define the valid values, e.g. "a" and "b" mean that the value has to be a or b.
The enumeration facet MUST NOT be specified for data types that are not derived from string.
Derived types MAY add additional enumeration values.  See A.2.5.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="enumerationRef" type="tns:EnumerationRefFacet">
        <xs:annotation>
          <xs:documentation>EnumerationRef facets allow a parameter's valid values to be obtained from another parameter.
The enumerationRef facet MUST NOT be specified for data types that are not derived from string.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="pattern" type="tns:PatternFacet">
        <xs:annotation>
          <xs:documentation>Pattern attributes, taken together, define valid patterns, e.g. "" and "[0-9A-Fa-f]{6}" means that the value has to be empty or a 6 digit hex string.
The pattern facet MUST NOT be specified for data types that are not derived from string.
Pattern syntax is the same as for XML Schema regular expressions.  See https://www.w3.org/TR/xmlschema-2/#regexs.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="units" type="tns:UnitsFacet">
        <xs:annotation>
          <xs:documentation>Multiple units facets MUST NOT be specified.
The units facet MUST NOT be specified for data types that are not numeric, i.e. data types that are not derived from one of the integer types.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>

  <!-- Complex types -->
  <xs:complexType name="Abbreviations">
    <xs:annotation>
      <xs:documentation>Abbreviations definition.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="description" type="tns:Description" minOccurs="0"/>
      <xs:element name="item" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="description" type="tns:Description">
              <xs:annotation>
                <xs:documentation>The description of the item.</xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="id" type="tns:AbbrefId" use="required">
            <xs:annotation>
              <xs:documentation>Uniquely identifies the item (this is checked by schema validation).  Can be referenced from descriptions by using the {{abbref}} template.  See A.2.2.4.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:anyAttribute namespace="##other"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ArgumentDefaultFacet">
    <xs:annotation>
      <xs:documentation>Argument parameter default facet.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseStatusFacet">
        <xs:attribute name="type" type="tns:ArgumentDefaultType" use="required"/>
        <xs:attribute name="value" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>Value MUST be valid for the data type.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ArgumentSyntax">
    <xs:annotation>
      <xs:documentation>Argument parameter syntax specification.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseSyntax">
        <xs:sequence>
          <xs:element name="default" type="tns:ArgumentDefaultFacet" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="BaseAccessFacet" abstract="true">
    <xs:annotation>
      <xs:documentation>Base facet (access, status and optional attributes).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseStatusFacet">
        <xs:attribute name="access" type="tns:ReadWriteAccess" default="readWrite"/>
        <xs:attribute name="optional" type="xs:boolean" default="false"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!-- XXX need to generalize this; want xs:anyAttribute nearer the type-root -->
  <xs:complexType name="BaseItem">
    <xs:annotation>
      <xs:documentation>Base Item.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="description" type="tns:Description" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="id" type="tns:OpaqueID"/>
    <xs:anyAttribute notNamespace="##local ##targetNamespace
      urn:broadband-forum-org:cwmp:datamodel-report-0-1
      urn:broadband-forum-org:cwmp:datamodel-report-1-0"/>
  </xs:complexType>
  <xs:complexType name="BaseParameter">
    <xs:annotation>
      <xs:documentation>Base Parameter.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseItem"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="BaseParameterDef">
    <xs:annotation>
      <xs:documentation>Base Parameter definition.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseParameter">
        <xs:attribute name="name" type="tns:ParameterName" use="required">
          <xs:annotation>
            <xs:documentation>MUST be unique within the parent object (this is checked by schema validation).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="version" type="tns:Version">
          <xs:annotation>
            <xs:documentation>MUST specify version if the item was defined in a later version than its parent.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="status" type="tns:Status"/>
        <xs:attribute ref="dmr:noNameCheck"/>
        <xs:attribute ref="dmr:noUnitsTemplate"/>
        <xs:attribute ref="dmr:previousCommand"/>
        <xs:attribute ref="dmr:previousEvent"/>
        <xs:attribute ref="dmr:previousParameter"/>
        <xs:attribute ref="dmr:customNumEntriesParameter"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!-- XXX BaseParameterMod (modification) would be more accurate (etc.) -->
  <xs:complexType name="BaseParameterRef">
    <xs:annotation>
      <xs:documentation>Base Parameter reference.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseParameter">
        <xs:attribute name="base" type="tns:ParameterName" use="required">
          <xs:annotation>
            <xs:documentation>MUST be unique within the parent object (this is checked by schema validation).
MUST reference an existing parameter.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="version" type="tns:Version">
          <xs:annotation>
            <xs:documentation>MUST specify version if the item was defined in a later version than its parent.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="status" type="tns:Status"/>
        <!-- XXX experimental: could extend to cover all unnecessary defaults
                 (but be careful; what if resetting non-default back to default?) (etc.) -->
        <!-- <xs:assert test="not(@status eq 'current')"/> -->
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="BaseObject">
    <xs:annotation>
      <xs:documentation>Base Object.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseItem">
        <xs:sequence>
          <xs:element name="uniqueKey" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation>MUST NOT be present if the object is not a table (see maxEntries).
                The parameters referenced by each unique key element MUST constitute a unique key.
                All of the referenced parameters MUST be single-valued (i.e. not list-valued).
                For a non-functional key, or if the table has no enableParameter, the uniqueness requirement always applies.
                For a functional key, and if the table has an enableParameter, the uniqueness requirement applies only to enabled table entries.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="parameter" maxOccurs="unbounded">
                  <xs:complexType>
                    <xs:attribute name="ref" type="tns:UniqueKeyReference" use="required"/>
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
              <xs:attribute name="functional" type="xs:boolean" use="required">
                <xs:annotation>
                  <xs:documentation>Indicates whether this is a functional (true) or non-functional (false) key.</xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:complexType>
            <xs:unique name="uniqueKeyParameterRef">
              <xs:selector xpath="parameter"/>
              <xs:field xpath="@ref"/>
            </xs:unique>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="minEntries" type="xs:nonNegativeInteger" default="1">
          <xs:annotation>
            <xs:documentation>minEntries MUST be less than or equal to maxEntries (all values are regarded as being less than "unbounded").</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maxEntries" type="tns:MaxEntries" default="1">
          <xs:annotation>
            <xs:documentation>minEntries and maxEntries indicate whether the object is a table:
              * minEntries=0, maxEntries=1 : single-instance object which might not be allowed to exist, e.g. because only one of it and another object can exist at the same time
              * minEntries=1, maxEntries=1 : single-instance object that is always allowed to exist
              * all other cases : object is a table</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="discriminatorParameter" type="tns:ParameterName">
          <xs:annotation>
            <xs:documentation>MUST be present and specified for all single-instance objects which are part of a union and point to the same parameter specifying the name of the object which is currently in use, i.e. only one object which is part of a union can exist at the same time.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="BaseObjectDef">
    <xs:annotation>
      <xs:documentation>Base Object definition.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseObject">
        <xs:attribute name="name" type="tns:ObjectName" use="required">
          <xs:annotation>
            <xs:documentation>MUST be unique within the component or model (this is checked by schema validation).
              If the object is a table (see maxEntries), the final part of the name MUST be "{i}.".</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="status" type="tns:Status"/>
        <xs:attribute ref="dmr:noNameCheck"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="BaseObjectRef">
    <xs:annotation>
      <xs:documentation>Base Object reference.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseObject">
        <xs:attribute name="base" type="tns:ObjectName">
          <xs:annotation>
            <xs:documentation>MUST reference an existing object.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="status" type="tns:Status"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="BaseStatusFacet" abstract="true">
    <xs:annotation>
      <xs:documentation>Base facet (status attribute).</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="description" type="tns:Description" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="status" type="tns:Status"/>
    <xs:anyAttribute namespace="##other"/>
  </xs:complexType>
  <xs:complexType name="BaseSyntax">
    <xs:annotation>
      <xs:documentation>Base parameter syntax specification (omits defaults).</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice>
        <xs:element name="list" type="tns:ListFacet" minOccurs="0">
          <xs:annotation>
            <xs:documentation>For lists, the TR-069 parameter is always a string and the data type specification applies to individual list items, not to the parameter value.
              See section 3.2 for comma-separated list formatting rules.</xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:choice>
      <xs:choice>
        <xs:group ref="tns:AllBuiltinDataTypes">
          <xs:annotation>
            <xs:documentation>Direct use of built-in data type, possibly modified via use of facets.</xs:documentation>
          </xs:annotation>
        </xs:group>
        <xs:element name="dataType" type="tns:DataTypeReference">
          <xs:annotation>
            <xs:documentation>Use of named data type, possibly modified via use of facets.</xs:documentation>
          </xs:annotation>
          <xs:unique name="dtRefEnumerationValue">
            <xs:selector xpath="enumeration"/>
            <xs:field xpath="@value"/>
          </xs:unique>
          <xs:unique name="dtRefPatternValue">
            <xs:selector xpath="pattern"/>
            <xs:field xpath="@value"/>
          </xs:unique>
        </xs:element>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="hidden" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>If true, MUST always read back as the null value for the parameter's base data type (A.2.3.5).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secured" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>The same as "hidden", except that it has no effect if the management protocol permits the Controller to read the parameter value.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="command" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>If true, setting this parameter triggers an Agent action. Such a parameter is not part of the device configuration and MUST always read back as the null value for the parameter's base data type (A.2.3.5).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:anyAttribute namespace="##other"/>
  </xs:complexType>
  <xs:complexType name="Bibliography">
    <xs:annotation>
      <xs:documentation>Bibliography definition.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="description" type="tns:Description" minOccurs="0"/>
      <xs:element name="reference" type="tns:BibliographyReference" minOccurs="0"
        maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="BibliographyReference">
    <xs:annotation>
      <xs:documentation>Bibliography reference definition.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="name" type="xs:token">
        <xs:annotation>
          <xs:documentation>Name by which the referenced document is usually known, e.g. TR-069, RFC 2863.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="title" type="xs:token" minOccurs="0"/>
      <xs:element name="organization" type="xs:token" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Organization that published the referenced document, e.g. BBF, IEEE, IETF.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="category" type="xs:token" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Document category, e.g. TR (BBF), RFC (IETF).</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="date" type="xs:token" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Publication date.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="hyperlink" type="xs:anyURI"/>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="id" type="tns:BibrefId" use="required">
      <xs:annotation>
        <xs:documentation>Uniquely identifies the reference (this is checked by schema validation).  Can be referenced from descriptions by using the {{bibref}} template.  See A.2.2.4.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:anyAttribute namespace="##other"/>
  </xs:complexType>
  <xs:complexType name="CommandArguments">
    <xs:annotation>
      <xs:documentation>Command Arguments (input or output) definition or reference.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="description" type="tns:Description" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:element name="component" type="tns:ComponentReference"/>
        <xs:element name="parameter">
          <xs:alternative test="@name" type="tns:CommandParameterDef"/>
          <xs:alternative test="@base" type="tns:CommandParameterRef"/>
          <xs:alternative type="xs:error"/>
        </xs:element>
        <xs:element name="object">
          <xs:alternative test="@name" type="tns:CommandObjectDef"/>
          <xs:alternative test="@base" type="tns:CommandObjectRef"/>
          <xs:alternative type="xs:error"/>
        </xs:element>
      </xs:choice>
    </xs:sequence>
    <xs:anyAttribute namespace="##other"/>
  </xs:complexType>
  <xs:complexType name="CommandObjectDef">
    <xs:annotation>
      <xs:documentation>Command Object definition.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseObjectDef">
        <xs:sequence>
          <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="component" type="tns:ComponentReference"/>
            <xs:element name="parameter" minOccurs="0" maxOccurs="unbounded">
              <xs:alternative test="@name" type="tns:CommandParameterDef"/>
              <xs:alternative test="@base" type="tns:CommandParameterRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="version" type="tns:Version">
          <xs:annotation>
            <xs:documentation>MUST specify version if the item was defined in a later version than its parent.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute ref="dmr:noUniqueKeys"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CommandObjectRef">
    <xs:annotation>
      <xs:documentation>Command Object reference.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseObjectRef">
        <xs:sequence>
          <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="component" type="tns:ComponentReference"/>
            <xs:element name="parameter" minOccurs="0" maxOccurs="unbounded">
              <xs:alternative test="@name" type="tns:CommandParameterDef"/>
              <xs:alternative test="@base" type="tns:CommandParameterRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CommandParameterDef">
    <xs:annotation>
      <xs:documentation>Command Parameter definition.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseParameterDef">
        <xs:sequence>
          <xs:element name="syntax" type="tns:ArgumentSyntax" minOccurs="0"/>
        </xs:sequence>
        <xs:attributeGroup ref="tns:CommandAndEventParameterAttributesDef"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CommandParameterRef">
    <xs:annotation>
      <xs:documentation>Command Parameter reference.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseParameterRef">
        <xs:sequence>
          <xs:element name="syntax" type="tns:ArgumentSyntax" minOccurs="0"/>
        </xs:sequence>
        <xs:attributeGroup ref="tns:CommandAndEventParameterAttributesRef"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ComponentDefinition">
    <xs:annotation>
      <xs:documentation>Component definition.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="description" type="tns:Description" minOccurs="0"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="component" type="tns:ComponentReference"/>
        <xs:element name="parameter">
          <xs:alternative test="@name" type="tns:ComponentParameterDef"/>
          <xs:alternative test="@base" type="tns:ComponentParameterRef"/>
          <xs:alternative type="xs:error"/>
        </xs:element>
        <xs:element name="object">
          <xs:alternative test="@name" type="tns:ComponentObjectDef"/>
          <xs:alternative test="@base" type="tns:ComponentObjectRef"/>
          <xs:alternative type="xs:error"/>
          <xs:unique name="componentObjectParameterName">
            <xs:selector xpath="parameter"/>
            <xs:field xpath="@name"/>
          </xs:unique>
        </xs:element>
        <xs:element name="command">
          <xs:alternative test="@name" type="tns:ModelCommandDef"/>
          <xs:alternative test="@base" type="tns:ModelCommandRef"/>
          <xs:alternative type="xs:error"/>
        </xs:element>
        <xs:element name="event">
          <xs:alternative test="@name" type="tns:ModelEventDef"/>
          <xs:alternative test="@base" type="tns:ModelEventRef"/>
          <xs:alternative type="xs:error"/>
        </xs:element>
      </xs:choice>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="profile" type="tns:Profile"/>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="name" type="tns:ComponentName" use="required">
      <xs:annotation>
        <xs:documentation>MUST be unique within the document, including imported components (this is checked by schema validation).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="virtual" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>If true, the first non-virtual component in the call stack (if found) will be expanded rather than the virtual component.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="status" type="tns:Status"/>
    <xs:attribute name="id" type="tns:OpaqueID"/>
    <xs:attribute ref="dmr:noNameCheck"/>
    <xs:anyAttribute namespace="##other"/>
  </xs:complexType>
  <xs:complexType name="ComponentObjectDef">
    <xs:annotation>
      <xs:documentation>Component Object definition.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseObjectDef">
        <xs:sequence>
          <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="component" type="tns:ComponentReference"/>
            <xs:element name="parameter">
              <xs:alternative test="@name" type="tns:ComponentParameterDef"/>
              <xs:alternative test="@base" type="tns:ComponentParameterRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
            <xs:element name="command">
              <xs:alternative test="@name" type="tns:ModelCommandDef"/>
              <xs:alternative test="@base" type="tns:ModelCommandRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
            <xs:element name="event">
              <xs:alternative test="@name" type="tns:ModelEventDef"/>
              <xs:alternative test="@base" type="tns:ModelEventRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
          </xs:choice>
        </xs:sequence>
        <xs:attributeGroup ref="tns:ModelObjectAttributesDef"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ComponentObjectRef">
    <xs:annotation>
      <xs:documentation>Component Object definition and reference.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseObjectRef">
        <xs:sequence>
          <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="component" type="tns:ComponentReference"/>
            <xs:element name="parameter">
              <xs:alternative test="@name" type="tns:ComponentParameterDef"/>
              <xs:alternative test="@base" type="tns:ComponentParameterRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
            <xs:element name="command">
              <xs:alternative test="@name" type="tns:ModelCommandDef"/>
              <xs:alternative test="@base" type="tns:ModelCommandRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
            <xs:element name="event">
              <xs:alternative test="@name" type="tns:ModelEventDef"/>
              <xs:alternative test="@base" type="tns:ModelEventRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
          </xs:choice>
        </xs:sequence>
        <xs:attributeGroup ref="tns:ModelObjectAttributesRef"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ComponentParameterDef">
    <xs:annotation>
      <xs:documentation>Component Parameter definition.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:ModelParameterDef">
        <xs:attributeGroup ref="tns:CommandAndEventParameterAttributesDef"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ComponentParameterRef">
    <xs:annotation>
      <xs:documentation>Component Parameter reference.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:ModelParameterRef">
        <xs:attributeGroup ref="tns:CommandAndEventParameterAttributesRef"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ComponentReference">
    <xs:annotation>
      <xs:documentation>Component reference.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="ref" type="tns:ComponentName" use="required">
      <xs:annotation>
        <xs:documentation>Name of component to be referenced (included).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="path" type="tns:ObjectName">
      <xs:annotation>
        <xs:documentation>If specified, is relative path between point of reference (inclusion) and the component's items.  If not specified, behavior is as if an empty relative path was specified.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="version" type="tns:Version">
      <xs:annotation>
        <xs:documentation>Version (if specified) clamps earlier versions at the specified version.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:anyAttribute namespace="##other"/>
  </xs:complexType>
  <xs:complexType name="DataTypeDefinition">
    <xs:annotation>
      <xs:documentation>Parameter data type definition.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="description" type="tns:Description" minOccurs="0"/>
      <xs:choice minOccurs="0">
        <xs:element name="list" type="tns:ListFacet" minOccurs="0"/>
      </xs:choice>
      <xs:choice>
        <xs:group ref="tns:AllFacets" minOccurs="0" maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation>Facets MUST NOT be specified if the base attribute is omitted.</xs:documentation>
          </xs:annotation>
        </xs:group>
        <xs:group ref="tns:AllBuiltinDataTypes" minOccurs="0">
          <xs:annotation>
            <xs:documentation>A built-in data type element MUST NOT be specified if the base attribute is present.
See tns:AllFacets for notes and requirements on individual facets.</xs:documentation>
          </xs:annotation>
        </xs:group>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="name" type="tns:DataTypeName" use="required">
      <xs:annotation>
        <xs:documentation>MUST be unique within the document, including imported data types (this is checked by schema validation).
Cannot begin with a lower-case letter, in order to avoid confusion with built-in data types.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="base" type="tns:DataTypeName">
      <xs:annotation>
        <xs:documentation>MUST be present if and only if deriving from a non-built-in data type.  See A.2.3.1.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="status" type="tns:Status"/>
    <xs:attribute name="id" type="tns:OpaqueID"/>
    <xs:anyAttribute namespace="##other"/>
  </xs:complexType>
  <xs:complexType name="DataTypeReference">
    <xs:annotation>
      <xs:documentation>Parameter data type reference or anonymous restriction / extension.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="tns:AllFacets" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="ref" type="tns:DataTypeName">
      <xs:annotation>
        <xs:documentation>If specified, content MUST be empty.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="base" type="tns:DataTypeName">
      <xs:annotation>
        <xs:documentation>If specified, content MUST NOT be empty.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:anyAttribute namespace="##other"/>
  </xs:complexType>
  <xs:complexType name="Description">
    <xs:annotation>
      <xs:documentation>Description: free text which MAY contain a limited amount of mediawiki-like markup as specified in A.2.2.  For example, use "*" at the start of a line to indicate a bulleted list.
To avoid confusion, the description SHOULD NOT contain tab characters.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="action" type="tns:DescriptionAction" default="create">
          <xs:annotation>
            <xs:documentation>This MUST be specified when the description modifies that of a previously defined item.
Specify "prefix" to prefix to the previous description, "append" to append to the previous description, or "replace" to replace the previous description.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
  <xs:complexType name="DescriptionTemplate">
    <xs:annotation>
      <xs:documentation>Named block of text that can be included in descriptions.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="id" type="tns:String">
          <xs:annotation>
            <xs:documentation>Uniquely identifies the item (this is checked by schema validation).  Can be referenced from descriptions by using the {{template}} template.  See A.2.2.4.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
  <xs:complexType name="EnumerationFacet">
    <xs:annotation>
      <xs:documentation>Enumeration facet.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseAccessFacet">
        <xs:attribute name="value" type="tns:String" use="required"/>
        <xs:attribute name="code" type="xs:integer"/>
        <xs:attribute name="version" type="tns:Version">
          <xs:annotation>
            <xs:documentation>MUST specify version if the item was defined in a later version than its parent.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute ref="dmr:noNameCheck"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="EnumerationRefFacet">
    <xs:annotation>
      <xs:documentation>Enumeration reference facet.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseStatusFacet">
        <xs:attribute name="targetParam" type="tns:ParameterReference" use="required">
          <xs:annotation>
            <xs:documentation>MUST reference a list-valued parameter.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="targetParamScope" type="tns:PathScope" default="normal">
          <xs:annotation>
            <xs:documentation>Specifies the point in the naming hierarchy relative to which targetParam applies (A.2.3.4).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="nullValue" type="tns:String">
          <xs:annotation>
            <xs:documentation>Specifies the value that indicates that none of the values of the referenced parameter currently apply.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="EventObjectDef">
    <xs:annotation>
      <xs:documentation>Event Object definition.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseObjectDef">
        <xs:sequence>
          <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="component" type="tns:ComponentReference"/>
            <xs:element name="parameter" minOccurs="0" maxOccurs="unbounded">
              <xs:alternative test="@name" type="tns:EventParameterDef"/>
              <xs:alternative test="@base" type="tns:EventParameterRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="version" type="tns:Version">
          <xs:annotation>
            <xs:documentation>MUST specify version if the item was defined in a later version than its parent.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute ref="dmr:noUniqueKeys"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="EventObjectRef">
    <xs:annotation>
      <xs:documentation>Event Object reference.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseObjectRef">
        <xs:sequence>
          <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="component" type="tns:ComponentReference"/>
            <xs:element name="parameter" minOccurs="0" maxOccurs="unbounded">
              <xs:alternative test="@name" type="tns:EventParameterDef"/>
              <xs:alternative test="@base" type="tns:EventParameterRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="EventParameterDef">
    <xs:annotation>
      <xs:documentation>Event Parameter definition.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseParameterDef">
        <xs:sequence>
          <xs:element name="syntax" type="tns:ArgumentSyntax" minOccurs="0"/>
        </xs:sequence>
        <xs:attributeGroup ref="tns:CommandAndEventParameterAttributesDef"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="EventParameterRef">
    <xs:annotation>
      <xs:documentation>Event Parameter reference.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseParameterRef">
        <xs:sequence>
          <xs:element name="syntax" type="tns:ArgumentSyntax" minOccurs="0"/>
        </xs:sequence>
        <xs:attributeGroup ref="tns:CommandAndEventParameterAttributesRef"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Glossary">
    <xs:annotation>
      <xs:documentation>Glossary definition.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="description" type="tns:Description" minOccurs="0"/>
      <xs:element name="item" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="description" type="tns:Description">
              <xs:annotation>
                <xs:documentation>The description of the item.</xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="id" type="tns:GlorefId" use="required">
            <xs:annotation>
              <xs:documentation>Uniquely identifies the item (this is checked by schema validation).  Can be referenced from descriptions by using the {{gloref}} template.  See A.2.2.4.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:anyAttribute namespace="##other"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="Import">
    <xs:annotation>
      <xs:documentation>Import data types, components and models (Root and Service Objects) from external documents.  All such items MUST be imported (this is checked by schema validation).
The optional ref attribute MAY be used in order to avoid name conflicts between imported and locally-defined items.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="dataType">
          <xs:complexType>
            <xs:attribute name="name" type="tns:DataTypeName" use="required"/>
            <xs:attribute name="ref" type="tns:DataTypeName">
              <xs:annotation>
                <xs:documentation>If omitted, data type is known by the same name in both this and the referenced document.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="component">
          <xs:complexType>
            <xs:attribute name="name" type="tns:ComponentName" use="required"/>
            <xs:attribute name="ref" type="tns:ComponentName">
              <xs:annotation>
                <xs:documentation>If omitted, component is known by the same name in both this and the referenced document.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="model">
          <xs:complexType>
            <xs:attribute name="name" type="tns:ModelName" use="required"/>
            <xs:attribute name="ref" type="tns:ModelName">
              <xs:annotation>
                <xs:documentation>If omitted, model is known by the same name in both this and the referenced document.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="file" type="xs:anyURI" use="required">
      <xs:annotation>
        <xs:documentation>MUST be used to locate the DM Instance (A.2.1).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="spec" type="xs:anyURI">
      <xs:annotation>
        <xs:documentation>If specified, processing tools MUST regard a mismatch between this and the external document's spec attribute as an error.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:anyAttribute namespace="##other"/>
  </xs:complexType>
  <xs:complexType name="InstanceRefFacet">
    <xs:annotation>
      <xs:documentation>Instance number reference facet.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseStatusFacet">
        <xs:attribute name="refType" type="tns:ReferenceType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the type of reference (A.2.3.6).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="targetParent" type="tns:ObjectReference" use="required">
          <xs:annotation>
            <xs:documentation>MUST reference a multi-instance object (table) (A.2.3.4).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="targetParentScope" type="tns:PathScope" default="normal">
          <xs:annotation>
            <xs:documentation>Specifies the point in the naming hierarchy relative to which targetParent applies (A.2.3.4).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ListFacet">
    <xs:annotation>
      <xs:documentation>List facet.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseStatusFacet">
        <xs:sequence>
          <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="size" type="tns:SizeFacet">
              <xs:annotation>
                <xs:documentation>This specifies the size of the TR-069 list-valued parameter, not of the individual list items.</xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="minItems" type="xs:nonNegativeInteger" default="0"/>
        <xs:attribute name="maxItems" type="tns:MaxEntries" default="unbounded"/>
        <xs:attribute name="nestedBrackets" type="tns:ListNesting" default="legacy"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Model">
    <xs:annotation>
      <xs:documentation>Model (Root or Service Object) definition and reference.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="description" type="tns:Description" minOccurs="0"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="component" type="tns:ComponentReference"/>
        <xs:element name="parameter">
          <xs:alternative test="@name" type="tns:ModelParameterDef"/>
          <xs:alternative test="@base" type="tns:ModelParameterRef"/>
          <xs:alternative type="xs:error"/>
        </xs:element>
        <xs:element name="object">
          <xs:alternative test="@name" type="tns:ModelObjectDef"/>
          <xs:alternative test="@base" type="tns:ModelObjectRef"/>
          <xs:alternative type="xs:error"/>
          <xs:unique name="objectParameterName">
            <xs:selector xpath="parameter"/>
            <xs:field xpath="@name"/>
          </xs:unique>
        </xs:element>
      </xs:choice>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="profile" type="tns:Profile"/>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="name" type="tns:ModelName" use="required">
      <xs:annotation>
        <xs:documentation>MUST be unique within the document, including imported models (this is checked by schema validation).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="base" type="tns:ModelName">
      <xs:annotation>
        <xs:documentation>MUST be present if and only if extending an existing model.  See A.2.10.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="version" type="tns:Version">
      <xs:annotation>
        <xs:documentation>MUST specify version for patches (Corrigenda).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="isService" type="xs:boolean" default="false"/>
    <xs:attribute name="status" type="tns:Status"/>
    <xs:attribute name="id" type="tns:OpaqueID"/>
    <xs:attribute ref="dmr:noNameCheck"/>
    <xs:anyAttribute namespace="##other"/>
  </xs:complexType>
  <xs:complexType name="ModelCommandBase">
    <xs:annotation>
      <xs:documentation>Model Command base.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseItem">
        <xs:sequence>
          <xs:element minOccurs="0" name="input" type="tns:CommandArguments"/>
          <xs:element minOccurs="0" name="output" type="tns:CommandArguments"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ModelCommandDef">
    <xs:annotation>
      <xs:documentation>Model Command definition.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:ModelCommandBase">
        <xs:attribute name="name" type="tns:CommandName" use="required">
          <xs:annotation>
            <xs:documentation>MUST be unique within the parent object (this is checked by schema validation).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="version" type="tns:Version">
          <xs:annotation>
            <xs:documentation>MUST specify version if the item was defined in a later version than its parent.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="async" type="xs:boolean" use="required"/>
        <xs:attribute name="status" type="tns:Status"/>
        <xs:attribute ref="dmr:noUnitsTemplate"/>
        <xs:attribute ref="dmr:previousCommand"/>
        <xs:attribute ref="dmr:previousEvent"/>
        <xs:attribute ref="dmr:previousParameter"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ModelCommandRef">
    <xs:annotation>
      <xs:documentation>Model Command reference.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:ModelCommandBase">
        <xs:attribute name="base" type="tns:CommandName">
          <xs:annotation>
            <xs:documentation>MUST be unique within the parent object (this is checked by schema validation).
MUST reference an existing command.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="status" type="tns:Status"/>
        <xs:attribute name="async" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ModelDefaultFacet">
    <xs:annotation>
      <xs:documentation>Model parameter default facet.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseStatusFacet">
        <xs:attribute name="type" type="tns:ModelDefaultType" use="required"/>
        <xs:attribute name="value" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>Value MUST be valid for the data type.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ModelEventBase">
    <xs:annotation>
      <xs:documentation>Model Event base.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseItem">
        <xs:sequence>
          <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="component" type="tns:ComponentReference"/>
            <xs:element name="parameter">
              <xs:alternative test="@name" type="tns:EventParameterDef"/>
              <xs:alternative test="@base" type="tns:EventParameterRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
            <xs:element name="object">
              <xs:alternative test="@name" type="tns:EventObjectDef"/>
              <xs:alternative test="@base" type="tns:EventObjectRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ModelEventDef">
    <xs:annotation>
      <xs:documentation>Model Event definition.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:ModelEventBase">
        <xs:attribute name="name" type="tns:EventName" use="required">
          <xs:annotation>
            <xs:documentation>MUST be unique within the parent object (this is checked by schema validation).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="version" type="tns:Version">
          <xs:annotation>
            <xs:documentation>MUST specify version if the item was defined in a later version than its parent.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="status" type="tns:Status"/>
        <xs:attribute ref="dmr:noUnitsTemplate"/>
        <xs:attribute ref="dmr:previousCommand"/>
        <xs:attribute ref="dmr:previousEvent"/>
        <xs:attribute ref="dmr:previousParameter"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ModelEventRef">
    <xs:annotation>
      <xs:documentation>Model Event reference.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:ModelEventBase">
        <xs:attribute name="base" type="tns:EventName" use="required">
          <xs:annotation>
            <xs:documentation>MUST be unique within the parent object (this is checked by schema validation).
MUST reference an existing event.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="status" type="tns:Status"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ModelObjectDef">
    <xs:annotation>
      <xs:documentation>Model Object definition.  See A.2.8.1 for details of how tables are represented.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseObjectDef">
        <xs:sequence>
          <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="component" type="tns:ComponentReference"/>
            <xs:element name="parameter">
              <xs:alternative test="@name" type="tns:ModelParameterDef"/>
              <xs:alternative test="@base" type="tns:ModelParameterRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
            <xs:element name="command">
              <xs:alternative test="@name" type="tns:ModelCommandDef"/>
              <xs:alternative test="@base" type="tns:ModelCommandRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
            <xs:element name="event">
              <xs:alternative test="@name" type="tns:ModelEventDef"/>
              <xs:alternative test="@base" type="tns:ModelEventRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
          </xs:choice>
        </xs:sequence>
        <xs:attributeGroup ref="tns:ModelObjectAttributesDef"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ModelObjectRef">
    <xs:annotation>
      <xs:documentation>Model Object reference.  See A.2.8.1 for details of how tables are represented.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseObjectRef">
        <xs:sequence>
          <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="component" type="tns:ComponentReference"/>
            <xs:element name="parameter">
              <xs:alternative test="@name" type="tns:ModelParameterDef"/>
              <xs:alternative test="@base" type="tns:ModelParameterRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
            <xs:element name="command">
              <xs:alternative test="@name" type="tns:ModelCommandDef"/>
              <xs:alternative test="@base" type="tns:ModelCommandRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
            <xs:element name="event">
              <xs:alternative test="@name" type="tns:ModelEventDef"/>
              <xs:alternative test="@base" type="tns:ModelEventRef"/>
              <xs:alternative type="xs:error"/>
            </xs:element>
          </xs:choice>
        </xs:sequence>
        <xs:attributeGroup ref="tns:ModelObjectAttributesRef"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ModelParameterDef">
    <xs:annotation>
      <xs:documentation>Model Parameter definition.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseParameterDef">
        <xs:sequence>
          <xs:element name="syntax" type="tns:ModelSyntax" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="access" type="tns:ParameterAccess" default="readOnly"/>
        <xs:attribute name="activeNotify" type="tns:ActiveNotify" default="normal"/>
        <xs:attribute name="forcedInform" type="xs:boolean" default="false"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ModelParameterRef">
    <xs:annotation>
      <xs:documentation>Model Parameter reference.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseParameterRef">
        <xs:sequence>
          <xs:element name="syntax" type="tns:ModelSyntax" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="access" type="tns:ParameterAccess"/>
        <xs:attribute name="activeNotify" type="tns:ActiveNotify"/>
        <xs:attribute name="forcedInform" type="xs:boolean"/>
        <!-- XXX etc. (or don't bother checking such things in the schema?) -->
        <!-- <xs:assert test="not(@access eq 'readOnly')"/> -->
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ModelSyntax">
    <xs:annotation>
      <xs:documentation>Model parameter syntax specification.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseSyntax">
        <xs:sequence>
          <xs:element name="default" type="tns:ModelDefaultFacet" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PathRefFacet">
    <xs:annotation>
      <xs:documentation>Path name reference facet.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseStatusFacet">
        <xs:attribute name="refType" type="tns:ReferenceType" use="required">
          <xs:annotation>
            <xs:documentation>Specifies the type of reference (A.2.3.6).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="targetParent" type="tns:ObjectReferencePatterns" default="">
          <xs:annotation>
            <xs:documentation>If the list is non-empty, this parameter MUST only reference immediate children of matching objects (A.2.3.4).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="targetParentScope" type="tns:PathScope" default="normal">
          <xs:annotation>
            <xs:documentation>Specifies the point in the naming hierarchy relative to which targetParent applies (A.2.3.4).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="targetType" type="tns:TargetType" default="any">
          <xs:annotation>
            <xs:documentation>Specifies the type of item that can be referenced.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="targetDataType" type="tns:AnyTypeName" default="any">
          <xs:annotation>
            <xs:documentation>Specifies the valid data types for a referenced parameter.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PatternFacet">
    <xs:annotation>
      <xs:documentation>Pattern facet (pattern syntax is as in XML Schema).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseAccessFacet">
        <xs:attribute name="value" type="xs:string" use="required"/>
        <xs:attribute name="version" type="tns:Version">
          <xs:annotation>
            <xs:documentation>MUST specify version if the item was defined in a later version than its parent.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Profile">
    <xs:annotation>
      <xs:documentation>Profile definition and reference.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="description" type="tns:Description" minOccurs="0">
        <xs:annotation>
          <xs:documentation>If the extends attribute is insufficient to express general profile requirements, any additional requirements MUST be specified here.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="parameter" type="tns:ProfileParameter"/>
        <xs:element name="object" type="tns:ProfileObject"/>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="name" type="tns:ProfileName">
      <xs:annotation>
        <xs:documentation>MUST be unique within the model (this is checked by schema validation).
MUST be present if and only if defining a new profile.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="base" type="tns:ProfileName">
      <xs:annotation>
        <xs:documentation>MUST specify base if modifying an existing profile or if the profile version is greater than 1.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="extends" type="tns:ProfileNames">
      <xs:annotation>
        <xs:documentation>MUST specify extends if the profile extends other profile(s).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="minVersion" type="tns:ModelNames">
      <xs:annotation>
        <xs:documentation>MUST specify minVersion if the profile is defined in a Component.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="version" type="tns:Version" use="required"/>
    <xs:attribute name="status" type="tns:Status"/>
    <xs:attribute name="id" type="tns:OpaqueID"/>
    <xs:attribute ref="dmr:noNameCheck"/>
    <xs:anyAttribute namespace="##other"/>
  </xs:complexType>
  <xs:complexType name="ProfileCommand">
    <xs:annotation>
      <xs:documentation>Profile command definition.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="description" type="tns:Description" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Any additional requirements MUST be specified here.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element minOccurs="0" name="input">
        <xs:complexType>
          <xs:choice maxOccurs="unbounded">
            <xs:element name="parameter">
              <xs:complexType>
                <xs:attribute name="ref" type="tns:ParameterName"/>
                <xs:attribute name="status" type="tns:Status"/>
              </xs:complexType>
            </xs:element>
            <xs:element name="object">
              <xs:complexType>
                <xs:sequence maxOccurs="unbounded" minOccurs="0">
                  <xs:element name="parameter">
                    <xs:complexType>
                      <xs:attribute name="ref" type="tns:ParameterName"/>
                      <xs:attribute name="status" type="tns:Status"/>
                    </xs:complexType>
                  </xs:element>
                </xs:sequence>
                <xs:attribute name="ref" type="tns:ObjectName"/>
                <xs:attribute name="status" type="tns:Status"/>
              </xs:complexType>
            </xs:element>
          </xs:choice>
        </xs:complexType>
      </xs:element>
      <xs:element minOccurs="0" name="output">
        <xs:complexType>
          <xs:choice maxOccurs="unbounded">
            <xs:element name="parameter">
              <xs:complexType>
                <xs:attribute name="ref" type="tns:ParameterName"/>
                <xs:attribute name="status" type="tns:Status"/>
              </xs:complexType>
            </xs:element>
            <xs:element name="object">
              <xs:complexType>
                <xs:sequence maxOccurs="unbounded" minOccurs="0">
                  <xs:element name="parameter">
                    <xs:complexType>
                      <xs:attribute name="ref" type="tns:ParameterName"/>
                      <xs:attribute name="status" type="tns:Status"/>
                    </xs:complexType>
                  </xs:element>
                </xs:sequence>
                <xs:attribute name="ref" type="tns:ObjectName"/>
                <xs:attribute name="status" type="tns:Status"/>
              </xs:complexType>
            </xs:element>
          </xs:choice>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="ref" type="tns:CommandName" use="required"/>
    <xs:attribute name="status" type="tns:Status"/>
    <xs:anyAttribute namespace="##other"/>
  </xs:complexType>
  <xs:complexType name="ProfileEvent">
    <xs:annotation>
      <xs:documentation>Profile event definition.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="description" type="tns:Description" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Any additional requirements MUST be specified here.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice maxOccurs="unbounded" minOccurs="0">
        <xs:element name="parameter">
          <xs:complexType>
            <xs:attribute name="ref" type="tns:ParameterName"/>
            <xs:attribute name="status" type="tns:Status"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="object">
          <xs:complexType>
            <xs:sequence maxOccurs="unbounded" minOccurs="0">
              <xs:element name="parameter">
                <xs:complexType>
                  <xs:attribute name="ref" type="tns:ParameterName"/>
                  <xs:attribute name="status" type="tns:Status"/>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
            <xs:attribute name="ref" type="tns:ObjectName"/>
            <xs:attribute name="status" type="tns:Status"/>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="ref" type="tns:EventName" use="required"/>
    <xs:attribute name="status" type="tns:Status"/>
    <xs:anyAttribute namespace="##other"/>
  </xs:complexType>
  <xs:complexType name="ProfileObject">
    <xs:annotation>
      <xs:documentation>Profile object definition.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="description" type="tns:Description" minOccurs="0">
        <xs:annotation>
          <xs:documentation>If the requirement attribute is insufficient to express the requirement, any additional requirements MUST be specified here and MAY override the attribute.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice maxOccurs="unbounded" minOccurs="0">
        <xs:element name="parameter" type="tns:ProfileParameter"/>
        <xs:element name="command" type="tns:ProfileCommand">
          <xs:annotation>
            <xs:documentation>If no argument requirements are listed, this is the same as if just the mandatory arguments were listed.</xs:documentation>
            <xs:documentation>If any argument requirements are given then all the mandatory arguments MUST be listed, and additional arguments MAY be listed.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="event" type="tns:ProfileEvent">
          <xs:annotation>
            <xs:documentation>If no argument requirements are listed, this is the same as if just the mandatory arguments were listed.</xs:documentation>
            <xs:documentation>If any argument requirements are given then all the mandatory arguments MUST be listed, and additional arguments MAY be listed.</xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="ref" type="tns:ObjectName" use="required"/>
    <xs:attribute name="requirement" type="tns:ProfileObjectAccess" use="required"/>
    <xs:attribute name="status" type="tns:Status"/>
    <xs:anyAttribute namespace="##other"/>
  </xs:complexType>
  <xs:complexType name="ProfileParameter">
    <xs:annotation>
      <xs:documentation>Profile parameter definition.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="description" type="tns:Description" minOccurs="0">
        <xs:annotation>
          <xs:documentation>If the requirement attribute is insufficient to express the requirement, any additional requirements MUST be specified here and MAY override the attribute.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="ref" type="tns:ParameterName" use="required"/>
    <xs:attribute name="requirement" type="tns:ParameterAccess" use="required"/>
    <xs:attribute name="status" type="tns:Status"/>
    <xs:anyAttribute namespace="##other"/>
  </xs:complexType>
  <xs:complexType name="DecimalRangeFacet">
    <xs:annotation>
      <xs:documentation>Decimal range facet.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseAccessFacet">
        <xs:attribute name="minInclusive" type="xs:decimal"/>
        <xs:attribute name="maxInclusive" type="xs:decimal"/>
        <xs:attribute name="step" default="1">
          <xs:simpleType>
            <xs:restriction base="xs:decimal">
              <xs:minExclusive value="0"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RangeFacet">
    <xs:annotation>
      <xs:documentation>Integer range facet with optional step.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseAccessFacet">
        <xs:attribute name="minInclusive" type="xs:integer"/>
        <xs:attribute name="maxInclusive" type="xs:integer"/>
        <xs:attribute name="step" type="xs:positiveInteger" default="1"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SizeFacet">
    <xs:annotation>
      <xs:documentation>Size facet.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseAccessFacet">
        <xs:attribute name="minLength" type="xs:nonNegativeInteger" default="0"/>
        <xs:attribute name="maxLength" type="xs:nonNegativeInteger"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="UnitsFacet">
    <xs:annotation>
      <xs:documentation>Units facet.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:BaseStatusFacet">
        <xs:attribute name="value" type="tns:UnitsString" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!-- Elements -->
  <xs:element name="document">
    <xs:annotation>
      <xs:documentation>CWMP Data Model Definition XML Schema (DM Schema) instance documents can contain any or all of the following:
* Data type definitions
* Root Object definitions (including profiles)
* Service Object definitions (including profiles)
* Component definitions
* Vendor extension definitions
BBF standard DM Schema instance documents MUST use UTF-8 encoding and their character set MUST be restricted to printable characters in the Basic Latin Unicode block, i.e. to characters whose decimal ASCII representations are in the (inclusive) ranges 9-10 and 32-126.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:all>
        <xs:element name="description" type="tns:Description" minOccurs="0">
          <xs:annotation>
            <xs:documentation>Top-level description.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="import" type="tns:Import" minOccurs="0" maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation>Imported data types, components and models (Root and Service Objects).</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="dataType" type="tns:DataTypeDefinition" minOccurs="0"
          maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation>Top-level data type definitions.</xs:documentation>
          </xs:annotation>
          <xs:unique name="dtDefEnumerationValue">
            <xs:selector xpath="enumeration"/>
            <xs:field xpath="@value"/>
          </xs:unique>
          <xs:unique name="dtDefPatternValue">
            <xs:selector xpath="pattern"/>
            <xs:field xpath="@value"/>
          </xs:unique>
        </xs:element>
        <xs:element name="glossary" type="tns:Glossary" minOccurs="0">
          <xs:annotation>
            <xs:documentation>Glossary items.</xs:documentation>
          </xs:annotation>
          <xs:unique name="glossaryItem">
            <xs:selector xpath="item"/>
            <xs:field xpath="@id"/>
          </xs:unique>
        </xs:element>
        <xs:element name="abbreviations" type="tns:Abbreviations" minOccurs="0">
          <xs:annotation>
            <xs:documentation>Abbreviation items.</xs:documentation>
          </xs:annotation>
          <xs:unique name="abbreviationsItem">
            <xs:selector xpath="item"/>
            <xs:field xpath="@id"/>
          </xs:unique>
        </xs:element>
        <xs:element name="bibliography" type="tns:Bibliography" minOccurs="0">
          <xs:annotation>
            <xs:documentation>Bibliographic references.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="template" type="tns:DescriptionTemplate" minOccurs="0"
          maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation>Templates used in descriptions.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="component" type="tns:ComponentDefinition" minOccurs="0"
          maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation>Component definitions.</xs:documentation>
          </xs:annotation>
          <xs:unique name="componentParameterName">
            <xs:selector xpath="parameter"/>
            <xs:field xpath="@name"/>
          </xs:unique>
          <xs:unique name="componentObjectName">
            <xs:selector xpath="object"/>
            <xs:field xpath="@name"/>
          </xs:unique>
          <xs:unique name="componentProfileName">
            <xs:selector xpath="profile"/>
            <xs:field xpath="@name"/>
          </xs:unique>
        </xs:element>
        <xs:element name="model" type="tns:Model" minOccurs="0" maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation>Model (Root and Service Object) definitions.</xs:documentation>
          </xs:annotation>
          <xs:unique name="modelParameterName">
            <xs:selector xpath="parameter"/>
            <xs:field xpath="@name"/>
          </xs:unique>
          <xs:unique name="modelObjectName">
            <xs:selector xpath="object"/>
            <xs:field xpath="@name"/>
          </xs:unique>
          <xs:unique name="modelProfileName">
            <xs:selector xpath="profile"/>
            <xs:field xpath="@name"/>
          </xs:unique>
        </xs:element>
      </xs:all>
      <xs:attribute name="spec" use="required">
        <xs:annotation>
          <xs:documentation>URI of the associated specification document, e.g. the BBF Technical Report.  This URI SHOULD uniquely identify the specification.  More than one DM Schema instance document MAY reference the same specification.
Where the specification is a BBF document, the URI naming rules specified in A.2.1.1 MUST be used.  For example, to reference TR-106 Issue 1 Amendment 2, the value of this attribute would be urn:broadband-forum-org:tr-106-1-2-0.</xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:anyURI">
            <xs:pattern value=".+"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="file" use="required">
        <xs:annotation>
          <xs:documentation>File name (omitting directory name) of this document.
Where the specification is a BBF document, the file naming rules specified in A.2.1.1 MUST be used.  For example, for the data model defined in TR-106 Issue 1 Amendment 2, the value of this attribute would be tr-106-1-2-0.xml.</xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:anyURI">
            <xs:pattern value=".+"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:anyAttribute namespace="##other"/>
    </xs:complexType>
    <xs:unique name="dataTypeName">
      <xs:selector xpath="dataType | import/dataType"/>
      <xs:field xpath="@name"/>
    </xs:unique>
    <xs:unique name="componentName">
      <xs:selector xpath="component | import/component"/>
      <xs:field xpath="@name"/>
    </xs:unique>
    <xs:unique name="modelName">
      <xs:selector xpath="model | import/model"/>
      <xs:field xpath="@name"/>
    </xs:unique>
    <xs:unique name="bibId">
      <xs:selector xpath="bibliography/reference"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:unique name="templateId">
      <xs:selector xpath="template"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:keyref name="dataTypeBase" refer="tns:dataTypeName">
      <xs:selector xpath="dataType | .//parameter/syntax/dataType"/>
      <xs:field xpath="@base"/>
    </xs:keyref>
    <xs:keyref name="dataTypeRef" refer="tns:dataTypeName">
      <xs:selector xpath=".//parameter/syntax/dataType"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:keyref name="componentRef" refer="tns:componentName">
      <xs:selector xpath=".//component/component | .//model/component | .//object/component | .//input/component | .//output/component | .//event/component"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:keyref name="modelBase" refer="tns:modelName">
      <xs:selector xpath="model"/>
      <xs:field xpath="@base"/>
    </xs:keyref>
  </xs:element>
</xs:schema>
